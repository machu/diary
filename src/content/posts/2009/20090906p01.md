---
title: Sinatra on GAE/JRuby でデータを永続化する (Datastore編)
date: 2009-09-06T00:00:00.000Z
lastmod: 2009-09-06T17:15:46.000Z
draft: false
---

準備が整ったので、ようやく Datastore での CRUD 操作に挑戦する。 ここからは API のドキュメントが道しるべになる。

* [appengine-apis](http://appengine-jruby.googlecode.com/svn/trunk/rdoc/appengine-apis/index.html) … Ruby側のインタフェース
* [com.google.appengine.api.datastore](http://code.google.com/intl/ja/appengine/docs/java/javadoc/index.html?com/google/appengine/api/datastore/package-summary.html) … Java側のインタフェース

#### サンプルアプリ（歩数管理ソフト）

できあがったサンプルは以下の通り。 数日後に消すかもしれない。

[![GAE/JRuby sample app (using Datastore)](https://farm3.staticflickr.com/2528/3893613046_b530d0597e_m.jpg "GAE/JRuby sample app (using Datastore)")](http://www.flickr.com/photos/machu/3893613046/)

* <http://machu-jruby.appspot.com/>

日付や歩数に任意の文字列が入れられたりと、細かいところまでは作っていない。 でも、データの CRUD と検索の概要は分かると思う。

#### Datastore の概要を把握する (get, putとキーの関係)

ふたたびサンプルコードに目を通す。 データの永続化のために、 Datastore.put メソッドを呼んでいる。

```
require 'appengine-apis/datastore'

e = AppEngine::Datastore::Entity.new('Employee')
e[:name] = 'Fred'
e[:role] = 'Manager'
e['hire_date'] = Time.now

AppEngine::Datastore.put e
```

API を読むと [Datastore.get メソッド](http://code.google.com/intl/ja/appengine/docs/java/javadoc/com/google/appengine/api/datastore/DatastoreService.html#get%28com.google.appengine.api.datastore.Key%29)も存在する。 get では引数に key を渡してエンティティを取得している。 この key には、何を指定すればいいんだろう。

ここで行き詰まったので、立ち止まって Datastore の概念を調べてみる。

* [たけまる / Google App Engine のデータストアは Bigtable をどのように使っているのか](http://teahut.sakura.ne.jp/b/2008-04-21-1.html)
* [BigtableによるDatastoreの実装 - スティルハウスの書庫](http://d.hatena.ne.jp/kazunori_279/20090617/1245219785)

> Datastoreのエンティティテーブルとは
>
> * Datastoreのエンティティを保存するBigtableのテーブル
> * 個々のエンティティは、「エンティティキー」で識別される
> * 個々のエンティティのプロパティ内容は、すべて1つのカラムにシリアライズされて格納される

なるほど、 Bigtable というフラットで巨大な key-value ストアの上に、 Datastore というエンティティテーブルが存在するのか。 そして、「1つのカラムにシリアライズされて」というところがポイント。 細かいところまでは分からないけど、イメージだけはつかむ。

key に何が入るのかを試してみるために、以下のサンプルを作ってみる。 dateが日付 ("2009-09-06"のような文字列) で steps が歩数。 日付をキーとして、 Datastore に格納している。

```
# create new record
post '/record/' do
  @record = AppEngine::Datastore::Entity.new('Record', params[:date])
  @record[:date] = params[:date]
  @record[:steps] = params[:steps]
  new_key = AppEngine::Datastore.put(@record)   # new_key == record.key
```

Entity.newの第1引数 ('Record') がエンティティ名で、第2引数がエンティティを識別するための ID になる。 Datastore に格納するためのキーは、エンティティ名とIDから生成しているみたい。 キーは Entity オブジェクトの key メソッドでも取り出せるし、 Datastore.put の返り値にもなる。 Entity.new の時点で ID を空にした場合は、 Datastore.put の時点で自動的に ID が振られる模様。 キーについては、以下のドキュメントも参考になる。 Java のドキュメントは JDO の概念が混じっているので、少し混乱するけど。

* [GAE/Java: データの作成、取得、削除](http://code.google.com/intl/ja/appengine/docs/java/datastore/creatinggettinganddeletingdata.html)
* [GAE/Python: キーとエンティティ グループ](http://code.google.com/intl/ja/appengine/docs/python/datastore/keysandentitygroups.html)

Datastore からエンティティを取得するには、この key を使う。 key はエンティティ名とIDから生成できるので、日付をキーにして Datastore に保存した歩数を取り出すコードは以下のようになる。

```
# get one record
get '/record/:date' do
  # エンティティ名と日付からキーを生成
  @key = AppEngine::Datastore::Key.from_path('Record', params[:date])
  begin
    # キーから歩数データを取得する
    @record = AppEngine::Datastore.get(@key)
  rescue AppEngine::Datastore::EntityNotFound => e
    @record = {}
  end
  erb %{
    date: <%=h @record[:date] %><br />
    key: <%=h @key %><br />
    steps: <%=h @record[:steps] %><br />
  }
end
```

例えば、 Entity.new('Record', '2009-09-06')で生成した key は、値が "agttYWNodS1qcnVieXIWCxIGUmVjb3JkIgoyMDA5LTA5LTA2DA" となった。 ちなみに、 key の型は Java::ComGoogleAppengineApiDatastore::Key なので、ただの文字列を Datastore.put に渡してもうまく行かない。 Key.from\_path や Entity#key メソッドの返り値を使うこと。

同じように delete も試してみた。

```
# delete one record
delete '/record/:date' do
  @key = AppEngine::Datastore::Key.from_path('Record', params[:date])
  @record = AppEngine::Datastore.delete(@key)
```

これで動きそうなはずだけど、なぜか「no delete with arguments matching」というエラーが発生する。 とりあえず delete は後回し。

ここまでで、歩数管理ソフトの CRUD 操作ができた（Deleteだけ動いていないけど）。

#### Datastore でクエリを使う

キー（日付）を使った歩数データの出し入れができたけど、わざわざ日付を入力して歩数データを参照するのはちょっと面倒。 そこで、歩数データの一覧を取得してみる。

一覧を取得するにはクエリという機能を使う。 まずは、何も条件を指定せずに、歩数データの一覧を取得する。

```
# get all records
get '/record/' do
  query = AppEngine::Datastore::Query.new('Record')
  @records = query.fetch
```

@records は Datastore::Entity の配列（のようなもの）。 @records.each とすると、それぞれのエントリが取得できる。 （実際には、eachメソッドを呼んだ時点で検索が実行されるみたい）

条件を指定する場合は、fetchではなくfilterを使う。 以下のコードは、指定した歩数以上のデータを取得する例になる。

```
query = AppEngine::Datastore::Query.new('Record')
@records = query.filter('steps', AppEngine::Datastore::Query::GREATER_THAN_OR_EQUAL, params[:steps])
```

#### ここまでのまとめ

分かったこと。

* Datastore はキーを使ってオブジェクトを出し入れする。
* キーはエンティティ名とIDから一意に生成される。
* クエリを使うことで複数のエンティティを検索・取得できる。

まだ分かっていないこと。

* Datastore のクエリに指定できる条件 (RDBと違って検索条件は限られる)
* 関連を含むエンティティの扱い方

次は DataMapper を使っての CRUD か、もしくは Datastore での関連を試してみよう。

#### サンプルコード

[gist:181843](http://gist.github.com/181843)
